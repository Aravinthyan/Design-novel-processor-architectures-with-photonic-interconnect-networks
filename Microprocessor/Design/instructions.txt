Instruction format - final

15:10   9:5      4:0
XXXXXX  XXXXX    XXXXX
opcode operand1 operand2

- Total number of instructions are 64 = 2^6
- Total number of registers are 32 = 2^5

********************************************

Assembly
- ld regX regY
- load the value from the address held by regX in memory to regY

********************************************

Assembly
- str regX regY
- store the value in regY into the address in regX

********************************************

Assembly
- add regX regY 
- regY = regX + regY

********************************************

Assembly
- sub regX regY
- regY = regX - regY

********************************************

Assembly
- and regX regY
- regY = regX & regY

********************************************

Assembly
- or regX regY
- regY = regX | regY

********************************************

Assembly
- mov regX regY
- regY = regX

********************************************

Assembly
- cmp regX regY
- regX == regY?

********************************************

Assembly
- jz #label
Machine code
- 001000 00000 00000
- #label address (16 bits as well)
Info
- if the zero flag was set jump to the label else skip the label address and got to the next instruction

********************************************

Assembly
- jmp #label
Machine Code
- 001001 00000 00000
- #label address (16 bits as well)
Info
- jump unconditionally to the label specified

********************************************

Assembly
- movi regX #immediate
Machine Code
- movi regX regX
- #immediate
         regX  regX
- 001010 00000 00000
- #immediate (16 bits as well)
Info
- move the value stated by the #immediate into regX
********************************************

Assembly
- addi regX #immediate
Machine Code
- addi regX regX
- #immediate
	 regX  regX
- 001011 00000 00000
- #immediate (16 bits as well)
Info
- regX = regX + #immediate

********************************************

Assembly
- subi regX #immediate
Machine Code
- subi regX regX
- #immediate
	 regX  regX
- 001100 00000 00000
- #immediate (16 bits as well)
Info
- regX = regX - #immediate

********************************************

Assembly
- andi regX #immediate
Machine Code
- andi regX regX
- #immediate
	 regX  regX
- 001101 00000 00000
- #immediate (16 bits as well)
Info
- regX = regX & #immediate

********************************************

Assembly
- ori regX #immediate
Machine Code
- ori regX regX
- #immediate
	 regX  regX
- 001110 00000 00000
- #immediate (16 bits as well)
Info
- regX = regX | #immediate

********************************************

Assembly
- push regX
Machine Code
- push reg0 regX
	 reg0  regX
- 001111 00000 00000
Info
- push the contents of regX to the stack

********************************************

Assembly
- pop regX
Machine Code
- pop reg0 regX
	 reg0 regX
- 010000 00000 00000
Info
- pop the contents from the stack to regX

********************************************

Assembly
- call #label
Machine Code
- call reg0 reg0
- #label
	 reg0  reg0
- 010001 00000 00000
- #label (16 bits as well)
Info
- jump to the function with #label as reference

********************************************

Assembly
- return
Machine Code
- return reg0 reg0
	 reg0  reg0
- 010010 00000 00000
Info
- go back to where the function was called from

********************************************
